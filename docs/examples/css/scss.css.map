{"version":3,"sources":["../../../source/lib/normalize/index.css","examples.scss","../../../source/scss/jig/grid.scss","../../../source/scss/jig/breakpoints.scss"],"names":[],"mappings":"AAAA,yxDCOE,oCCaD,aACA,mBACA,sCCgTG,aD/S6C,KCgV3C,gBALoB,KAKpB,iBALoB,QAhItB,2CF3NF,oCEgWI,gBALoB,MAhItB,2CF3NF,oCEgWI,gBALoB,MAhItB,2CF3NF,oCEgWI,iBALoB,SAhItB,2CF3NF,oCEgWI,iBALoB,SFpVvB,wCACC,sBAEA,yDCoDD,uBDjDE,aAGD,0DC8CD,uBD3CE,YEwMD,2CFhMC,uDCmCF,uBDhCG,aAGD,uDC6BF,uBD1BG,YAGD,uDCuBF,uBDpBG,YAGD,uDCiBF,uBDdG,YAGD,uDCWF,uBDRG,aEqKF,gDF5JC,uDACC,uBE2JF,2CFlJC,uDCdH,wBDiBI,YAGD,uDCjBF,uBDoBG,cAGD,uDCvBF,uBAmED,eDxCI,YAGD,uDC9BF,uBA+DD,oBAIA,kBDlCI,QAEA,YACA,WAGD,uDCvCF,uBDyCG,QAEA,aAUJ,uCCtGD,aACA,mBACA,sCCgTG,aD/S6C,KCgV3C,gBALoB,KAKpB,YALoB,KAKpB,iBALoB,QAhItB,2CFxGF,uCE6OI,gBALoB,MAhItB,2CFxGF,uCE6OI,gBALoB,MAhItB,2CFxGF,uCE6OI,YALoB,MAhItB,2CFxGF,uCE6OI,YALoB,OAhItB,2CFxGF,uCE6OI,iBALoB,SAhItB,2CFxGF,uCE6OI,iBALoB,SF/NvB,2CACC,sBAEA,4DCjED,uBDoEE,YAGD,6DCvED,uBAmED,eDQG,YAGD,yDC9ED,uBAcA,oBDmEE,YE4ED,kEFpEC,0DACC,uBEmEF,2CF1DC,0DCnGF,uBDqGG,QAEA,UACA,YAGD,0DCvGF,oBAIA,mBDqGG,QAEA,YAGD,0DClHF,uBAIA,oBA2DD,qBAIA,kBDkDI,QAEA,YAGD,0DC1HF,uBAkBA,iBAIA,eAyCD,iBAIA,mBD0DI,QAEA,UACA,YAGD,0DCnIF,uBA+DD,mBAIA,iBDmEI,QACA,UAEA,WACA,YAEA,qBACA,wBEgBF,2CFPC,0DCtJF,uBAIA,oBAUA,oBAIA,iBAiDD,mBDsFI,QAEA,WACA,YAGD,0DC3JF,oBAIA,kBAMA,oBAIA,iBAiDD,mBD+FI,QAEA,YAGD,0DCvKF,uBAIA,oBAUA,oBAIA,iBAiDD,mBDuGI,QAEA,YAGD,0DC/KF,uBAIA,oBAcA,iBAIA,eAyCD,iBAIA,kBD+GI,QAEA,YACA,YAGD,0DCxLF,uBA+DD,qBD4HI,QAEA,WACA,YAEA,sBACA","file":"scss.css","sourcesContent":["/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:0.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace, monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace, monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,[type=\"button\"],[type=\"reset\"],[type=\"submit\"]{-webkit-appearance:button}button::-moz-focus-inner,[type=\"button\"]::-moz-focus-inner,[type=\"reset\"]::-moz-focus-inner,[type=\"submit\"]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type=\"button\"]:-moz-focusring,[type=\"reset\"]:-moz-focusring,[type=\"submit\"]:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:0.35em 0.75em 0.625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=\"checkbox\"],[type=\"radio\"]{box-sizing:border-box;padding:0}[type=\"number\"]::-webkit-inner-spin-button,[type=\"number\"]::-webkit-outer-spin-button{height:auto}[type=\"search\"]{-webkit-appearance:textfield;outline-offset:-2px}[type=\"search\"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}template{display:none}[hidden]{display:none}\n\n/*# sourceMappingURL=index.css.map */\n","@use 'defines' as *;\n@use 'jig' as * with ($JIG_LAYOUT : $JIG_LAYOUT);\n\n\n\n@mixin render(){\n\t#basic-grid-example {\n\t\t.examples > .scss {\n\t\t\t@include grid-container();\n\n\t\t\t@include attribute-for-breakpoints(background-color, $GRID_CONTAINER_BACKGROUNDCOLOR);\n\n\n\n\t\t\t> div {\n\t\t\t\tbackground-color: gray;\n\n\t\t\t\t&:nth-of-type(odd){\n\t\t\t\t\t@include grid-item(6);\n\n\t\t\t\t\theight: 100px;\n\t\t\t\t}\n\n\t\t\t\t&:nth-of-type(even){\n\t\t\t\t\t@include grid-item(6);\n\n\t\t\t\t\theight: 75px;\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t@include breakpoint(medium up){\n\t\t\t\t> div {\n\t\t\t\t\t&:nth-of-type(1) {\n\t\t\t\t\t\t@include grid-item(4);\n\n\t\t\t\t\t\theight: 100px;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(2) {\n\t\t\t\t\t\t@include grid-item(4);\n\n\t\t\t\t\t\theight: 80px;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(3) {\n\t\t\t\t\t\t@include grid-item(4);\n\n\t\t\t\t\t\theight: 60px;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(4) {\n\t\t\t\t\t\t@include grid-item(4);\n\n\t\t\t\t\t\theight: 40px;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(5) {\n\t\t\t\t\t\t@include grid-item(4);\n\n\t\t\t\t\t\theight: 20px;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t@include breakpoint(medium down){\n\t\t\t\t> div {\n\t\t\t\t\t&:nth-of-type(3) {\n\t\t\t\t\t\tbackground-color: aqua;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t@include breakpoint(large){\n\t\t\t\t> div {\n\t\t\t\t\t&:nth-of-type(1) {\n\t\t\t\t\t\t@include grid-item();\n\n\t\t\t\t\t\theight: 25vh;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(2) {\n\t\t\t\t\t\t@include grid-item(6);\n\n\t\t\t\t\t\theight: 12.5vh;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(3) {\n\t\t\t\t\t\t@include grid-item(6);\n\t\t\t\t\t\t@include grid-item-align($vertical:bottom);\n\n\t\t\t\t\t\theight: 10vh;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(4) {\n\t\t\t\t\t\t@include grid-item(4);\n\t\t\t\t\t\t@include grid-item-align(center, center);\n\t\t\t\t\t\torder: 2;\n\n\t\t\t\t\t\twidth: 100px;\n\t\t\t\t\t\theight: 5vh;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(5) {\n\t\t\t\t\t\t@include grid-item(4);\n\t\t\t\t\t\torder: 1;\n\n\t\t\t\t\t\theight: 10vh;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t#advanced-grid-example {\n\t\t.examples > .scss {\n\t\t\t@include grid-container();\n\n\t\t\t@include spacing-based-attribute(padding-top, 'xxl');\n\n\t\t\t@include attribute-for-breakpoints(background-color, $GRID_CONTAINER_BACKGROUNDCOLOR);\n\n\n\n\t\t\t> div {\n\t\t\t\tbackground-color: gray;\n\n\t\t\t\t&:nth-of-type(odd){\n\t\t\t\t\t@include grid-item(4);\n\n\t\t\t\t\theight: gutter-value(5.0);\n\t\t\t\t}\n\n\t\t\t\t&:nth-of-type(even){\n\t\t\t\t\t@include grid-item(4);\n\t\t\t\t\t@include grid-item-align(null, end);\n\n\t\t\t\t\theight: 75px;\n\t\t\t\t}\n\n\t\t\t\t&:first-of-type {\n\t\t\t\t\t@include grid-item($span:4, $row-span:2);\n\n\t\t\t\t\theight: auto;\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t@include breakpoint(xsmall only){\n\t\t\t\t> div {\n\t\t\t\t\t&:nth-of-type(3) {\n\t\t\t\t\t\tbackground-color: aqua;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t@include breakpoint(medium){\n\t\t\t\t> div {\n\t\t\t\t\t&:nth-of-type(1) {\n\t\t\t\t\t\t@include grid-item(4);\n\t\t\t\t\t\torder: 5;\n\n\t\t\t\t\t\twidth: 50%;\n\t\t\t\t\t\theight: gutter-value(3.0);\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(2) {\n\t\t\t\t\t\t@include grid-item($start:8, $end:12);\n\t\t\t\t\t\torder: 4;\n\n\t\t\t\t\t\theight: 80px;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(3) {\n\t\t\t\t\t\t@include grid-item($start:6, $span:2);\n\t\t\t\t\t\t@include grid-item-align(full, center);\n\t\t\t\t\t\torder: 3;\n\n\t\t\t\t\t\theight: 60px;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(4) {\n\t\t\t\t\t\t@include grid-item(8, $row-start:1, $row-end:3);\n\t\t\t\t\t\t@include grid-item-align('right', $vertical:'full');\n\t\t\t\t\t\torder: 2;\n\n\t\t\t\t\t\twidth: 50%;\n\t\t\t\t\t\theight: auto;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(5) {\n\t\t\t\t\t\t@include grid-item(4);\n\t\t\t\t\t\t@include grid-item-align(left, top);\n\t\t\t\t\t\torder: 1;\n\t\t\t\t\t\tz-index: 1;\n\n\t\t\t\t\t\twidth: 200%;\n\t\t\t\t\t\theight: 55px;\n\n\t\t\t\t\t\tbackground-color: red;\n\t\t\t\t\t\ttransform: rotate(5deg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t@include breakpoint(large){\n\t\t\t\t> div {\n\t\t\t\t\t&:nth-of-type(1) {\n\t\t\t\t\t\t@include grid-item($start:0, $span:4, $row-start:0, $row-span:1);\n\t\t\t\t\t\t@include grid-item-align($vertical:full);\n\t\t\t\t\t\torder: 1;\n\n\t\t\t\t\t\twidth: auto;\n\t\t\t\t\t\theight: 10vh;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(2) {\n\t\t\t\t\t\t@include grid-item($start:4, $end:8, $row-start:0, $row-span:2);\n\t\t\t\t\t\t@include grid-item-align($vertical:full);\n\t\t\t\t\t\torder: 2;\n\n\t\t\t\t\t\theight: auto;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(3) {\n\t\t\t\t\t\t@include grid-item($start:8, $span:4, $row-start:0, $row-span:3);\n\t\t\t\t\t\t@include grid-item-align($vertical:full);\n\t\t\t\t\t\torder: 3;\n\n\t\t\t\t\t\theight: auto;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(4) {\n\t\t\t\t\t\t@include grid-item($start:0, $span:4, $row-start:1, $row-end:2);\n\t\t\t\t\t\t@include grid-item-align(right, center);\n\t\t\t\t\t\torder: 4;\n\n\t\t\t\t\t\twidth: 100px;\n\t\t\t\t\t\theight: 10vh;\n\t\t\t\t\t}\n\n\t\t\t\t\t&:nth-of-type(5) {\n\t\t\t\t\t\t@include grid-item(6);\n\t\t\t\t\t\t@include grid-item-align(stretch);\n\t\t\t\t\t\torder: 5;\n\n\t\t\t\t\t\twidth: auto;\n\t\t\t\t\t\theight: 20vh;\n\n\t\t\t\t\t\tbackground-color: gray;\n\t\t\t\t\t\ttransform: rotate(0deg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","@use 'sass:meta';\n@use 'sass:string';\n@use 'sass:map';\n\n@use 'globals' as *;\n@use 'breakpoints';\n\n\n\n///\n/// Renders the basic properties of a grid container, which is the bracket element for elements, which are\n/// to be placed in a grid, thereby making the container, more or less, \"the grid itself\".\n///\n/// The basic characteristic of this container is the pre-definition of usable grid columns, according to our\n/// layout definition.\n///\n/// @example\n///   @include grid-container();\n///\n@mixin grid-container(){\n\tdisplay: grid;\n\tgrid-auto-flow: row;\n\tgrid-template-columns: repeat(map.get($jig---grid-config, 'columns'), 1fr);\n\t@include breakpoints.attributes-for-breakpoints((\n\t\t'grid-column-gap' : map.get($jig---grid-config, 'gutters', 'horizontal'),\n\t\t'grid-row-gap' : map.get($jig---grid-config, 'gutters', 'vertical')\n\t));\n}\n\n\n\n///\n/// Renders the basic properties of a grid item, which is an item inside a grid, being placed according to\n/// pre-defined columns.\n///\n/// The main purpose of this mixin is, to define the space, the item takes inside the grid. To do this, there are\n/// several means of definition. Either just giving it a column-based width, aligning it at the end of other,\n/// already existing items, or defining a specific area it should cover, by explicitly defining a start and end column\n/// or a combination of both.\n///\n/// Additionally, the item may also be defined to take up more than one row, adding the native grid capabilities to\n/// our concepts.\n///\n/// @param {?Number} [$span=null] - the width of the item in columns\n/// @param {?Number} [$start=null] - the horizontal start offset of the item in columns, may be combined with $end or $span\n/// @param {?Number} [$end=null] - the horizontal end offset of the item in columns, may be combined with $start or $span\n/// @param {?Number} [$row-span=null] - the height of the item in rows\n/// @param {?Number} [$row-start=null] - the vertical start offset of the item in rows, may be combined with $row-end or $row-span\n/// @param {?Number} [$row-end=null] - the vertical end offset of the item in rows, may be combined with $row-start or $row-span\n///\n/// @example\n///   @include grid-item(12);\n///   @include grid-item(6, 6);\n///   @include grid-item(null, 2, 2);\n///   @include grid-item(6, null, null, 2);\n///   @include grid-item(6, null, null, null, 0, 5);\n///\n@mixin grid-item(\n\t$span:null,\n\t$start:null,\n\t$end:null,\n\t$row-span:null,\n\t$row-start:null,\n\t$row-end:null\n){\n\t@if ($span == null) and ($start == null) {\n\t\tgrid-column-end: span map.get($jig---grid-config, 'columns');\n\t} @else {\n\t\t@if $span != null {\n\t\t\tgrid-column-end: span $span;\n\t\t}\n\n\t\t@if $start != null {\n\t\t\tgrid-column-start: $start + 1;\n\t\t}\n\n\t\t@if ($end != null) and ($span == null) {\n\t\t\tgrid-column-end: $end + 1;\n\t\t}\n\t}\n\n\t@if ($row-span != null) or ($row-start != null) {\n\t\t@if $row-span != null {\n\t\t\tgrid-row-end: span $row-span;\n\t\t}\n\n\t\t@if $row-start != null {\n\t\t\tgrid-row-start: $row-start + 1;\n\t\t}\n\n\t\t@if ($row-end != null) and ($row-span == null) {\n\t\t\tgrid-row-end: $row-end + 1;\n\t\t}\n\t}\n}\n\n\n\n///\n/// Renders properties of a grid item, to define the item's alignment inside the area defined for the item using\n/// the grid-item mixin. The usage of this only make sense for grid items.\n///\n/// @param {String} [$horizontal=null] - \"left\"/\"start\", \"right\"/\"end\", \"middle\"/\"center\" or \"full\"/\"stretch\"\n/// @param {String} [$vertical=null] - \"top\"/\"start\", \"bottom\"/\"end\", \"middle\"/\"center\" or \"full\"/\"stretch\"\n///\n/// @example\n///   @include grid-item-align('left');\n///   @include grid-item-align(center, center);\n///   @include grid-item-align(null, 'full');\n///\n@mixin grid-item-align($horizontal:null, $vertical:null){\n\t@if $horizontal == 'left' {\n\t\t$horizontal: 'start';\n\t} @else if $horizontal == 'right' {\n\t\t$horizontal: 'end';\n\t} @else if $horizontal == 'middle' {\n\t\t$horizontal: 'center';\n\t} @else if $horizontal == 'full' {\n\t\t$horizontal: 'stretch';\n\t}\n\n\t@if $vertical == 'top' {\n\t\t$vertical: 'start';\n\t} @else if $vertical == 'bottom' {\n\t\t$vertical: 'end';\n\t} @else if $vertical == 'middle' {\n\t\t$vertical: 'center';\n\t} @else if $vertical == 'full' {\n\t\t$vertical: 'stretch';\n\t}\n\n\t@if $horizontal != null {\n\t\tjustify-self: string.unquote($horizontal);\n\t}\n\n\t@if $vertical != null {\n\t\talign-self: string.unquote($vertical);\n\t}\n}\n\n\n\n///\n/// Returns the value of the defined distance between two columns/rows for a breakpoint.\n///\n/// The main usage for this is, to define a property value based on the current gutter.\n/// This is why the parameter order may seem flipped, but usually, you'd use this inside a breakpoint\n/// using auto-breakpoint detection, primarily rather working with the value itself. For other cases:\n/// Remember, that that you can simply use named parameters.\n///\n/// @param {Number} [$factor=1.0] - factor to apply to the finally evaluated gutter value, most helpful to get half a gutter for example\n/// @param {Number} [$add=0] - value to add to the finally evaluated gutter value, may also be negative to subtract\n/// @param {String} [$direction='horizontal'] - either \"horizontal\" or \"vertical\", determines the gutter direction in the grid\n/// @param {String} [$breakpoint='auto'] - a defined breakpoint name or \"auto\", to use the current breakpoint at the point of usage\n/// @return {Number} the determined gutter value with applied factor and/or addition\n///\n/// @example\n///   @include breakpoint(medium){\n///     padding-left: gutter-value(0.5);\n///   }\n///   margin-top: gutter-value($direction:'vertical', $breakpoint:'small');\n///\n@function gutter-value($factor:1.0, $add:0, $direction:'horizontal', $breakpoint:'auto'){\n\t$gutter: map.get($jig---grid-config, 'gutters', $direction);\n\t$res: null;\n\n\t@if $gutter != null {\n\t\t@if meta.type-of($gutter) == 'map' {\n\t\t\t$res: breakpoints.breakpoint-value($gutter, $breakpoint);\n\t\t} @else {\n\t\t\t$res: $gutter;\n\t\t}\n\t}\n\n\t@if $res == null {\n\t\t@error 'jig:gutter-value | could not resolve gutter, check direction and/or breakpoint';\n\t}\n\n\t@return ($res * $factor) + $add;\n}\n","@use 'sass:meta';\n@use 'sass:list';\n@use 'sass:map';\n\n@use 'globals' as *;\n@use 'util';\n\n\n\n$jig---auto-breakpoint: list.nth(map.keys($jig---breakpoint-config), 1);\n\n\n\n///\n/// Returns the current auto breakpoint value.\n///\n/// @return {String} the name of the current named auto breakpoint\n///\n/// @see set-auto-breakpoint\n/// @see reset-auto-breakpoint\n///\n/// @example\n///   get-auto-breakpoint()\n///     => 'medium'\n///\n@function get-auto-breakpoint(){\n\t@return $jig---auto-breakpoint;\n}\n\n\n\n///\n/// Sets the auto breakpoint to a named breakpoint value.\n/// Hint: in Sass we do _not_ have to do this manually, if we want to use auto breakpoint values,\n/// since blocks are always evaluated _after_ the block mixin around the block, which results\n/// in the block knowing the breakpoint value automatically from the mixin around it.\n///\n/// @param {String} $breakpoint - a named breakpoint defined in the jig layout\n/// @throws error if breakpoint is unknown\n///\n/// @see get-auto-breakpoint\n/// @see reset-auto-breakpoint\n///\n/// @example\n///   set-auto-breakpoint(medium)\n///   @include breakpoint(medium){\n///     ...\n///   }\n///\n@mixin set-auto-breakpoint($breakpoint){\n\t@if map.has-key($jig---breakpoint-config, $breakpoint) {\n\t\t$jig---auto-breakpoint: $breakpoint;\n\t} @else {\n\t\t@error 'jig:set-current-breakpoint | unknown named breakpoint \"#{$breakpoint}\"';\n\t}\n}\n\n\n\n///\n/// Resets the auto breakpoint to the first/smallest named breakpoint defined in the jig layout.\n/// Hint: this is automatically called at the end of the breakpoint mixin, so usually you should be fine\n/// never calling this manually\n///\n/// @see get-auto-breakpoint\n/// @see set-auto-breakpoint\n///\n/// @example\n///   reset-auto-breakpoint()\n///\n@mixin reset-auto-breakpoint(){\n\t$jig---auto-breakpoint: list.nth(map.keys($jig---breakpoint-config), 1);\n}\n\n\n\n///\n/// Returns if the given breakpoint is a registered named breakpoint to be found in the jig layout definition.\n///\n/// @param {String} $breakpoint - a named breakpoint defined in the jig layout\n/// @return {Boolean} true if breakpoint is a registered named breakpoint name\n///\n/// @example\n///   is-named-breakpoint(medium)\n///     => true\n///\n@function is-named-breakpoint($breakpoint){\n\t@return map.has-key($jig---breakpoint-config, $breakpoint);\n}\n\n\n\n///\n/// Returns a string to be used in a media query, which defines the range/bounds of a breakpoint with\n/// min and/or max value.\n///\n/// @param {?Number} [$min=null] - the min width of the breakpoint\n/// @param {?Number} [$max=null] - the max width of the breakpoint\n/// @return {String} the media query string for the breakpoint range\n///\n/// @example\n///   build-breakpoint-range(0, 767px)\n///     => '(min-width: 0) and (max-width: 767px)'\n///   build-breakpoint-range(null, 100rem)\n///     => '(max-width: 100rem)'\n///\n@function build-breakpoint-range($min:null, $max:null){\n\t@return util.str-join(\n\t\t[\n\t\t\tif($min != null, '(min-width: #{$min})', null),\n\t\t\tif($max != null, '(max-width: #{$max})', null)\n\t\t],\n\t\t' and '\n\t);\n}\n\n\n\n///\n/// Constructs a query to be used in a media query, based on a breakpoint definition.\n/// Also automatically converts values to rem.\n///\n/// Directions in composite definitions may be \"up\", \"down\" or \"only\".\n///\n/// You may also define the special breakpoints \"landscape\" or \"portrait\" to cover device orientations.\n///\n/// @param {?Number|Literal|List<String>} [$breakpoint-definition=0] - either a simple number or a composite definition of width and direction, where the width may either be a number or a name defined in the named layout breakpoints\n/// @return {String} the media query string for the breakpoint definition\n///\n/// @example\n///   build-breakpoint-query(200rem)\n///     => '(min-width: 200rem)'\n///   build-breakpoint-query(small down)\n///     => '(max-width: 199rem)'\n///   build-breakpoint-query(['large' 'only'])\n///     => '(min-width: 200rem) and (max-width: 499rem)'\n///   build-breakpoint-query(1024px only)\n///     => '(min-width: 64rem) and (max-width: 64rem)'\n///   build-breakpoint-query(landscape)\n///     => '(orientation: landscape)'\n///\n@function build-breakpoint-query($breakpoint-definition:0){\n\t$breakpoint: if($breakpoint-definition and (list.length($breakpoint-definition) > 0), list.nth($breakpoint-definition, 1), 0);\n\t$direction: if($breakpoint-definition and (list.length($breakpoint-definition) > 1), list.nth($breakpoint-definition, 2), 'up');\n\t$breakpoint-name: null;\n\t$next-breakpoint: null;\n\t$min: null;\n\t$max: null;\n\t$query-rem-conversion-base: 16px; // this is always 16px, no matter what is defined on <html>\n\n\t@if $breakpoint == 'overwrite' {\n\t\t@return '(min-width: 0)';\n\t} @else if ($breakpoint == 'landscape') or ($breakpoint == 'portrait') {\n\t\t@return '(orientation: #{$breakpoint})';\n\t} @else if meta.type-of($breakpoint) == 'string' {\n\t\t@if is-named-breakpoint($breakpoint) {\n\t\t\t$breakpoint-name: $breakpoint;\n\t\t\t$breakpoint: map.get($jig---breakpoint-config, $breakpoint-name);\n\t\t\t$next-breakpoint: util.map-next($jig---breakpoint-config, $breakpoint-name);\n\t\t} @else {\n\t\t\t@error 'jig:build-breakpoint-query | \"#{$breakpoint-definition}\" is not a defined breakpoint';\n\t\t}\n\t}\n\n\t@if ($breakpoint-name == null) and ($direction == 'only') {\n\t\t@error 'jig:build-breakpoint-query | only named media queries can have an \"only\" range';\n\t}\n\n\t@if ($direction == 'only') or ($direction == 'up') {\n\t\t$min: util.to-rem($breakpoint, $query-rem-conversion-base);\n\t}\n\n\t@if ($direction == 'only') or ($direction == 'down') {\n\t\t@if $breakpoint-name == null {\n\t\t\t$max: util.to-rem($breakpoint, $query-rem-conversion-base);\n\t\t} @else if $next-breakpoint != null {\n\t\t\t$max: util.to-rem($next-breakpoint, $query-rem-conversion-base) - util.to-rem(1px, $query-rem-conversion-base);\n\t\t}\n\t}\n\n\t@if ($min == 0) and ($max == null){\n\t\t$min: null;\n\t}\n\n\t@return build-breakpoint-range($min, $max);\n}\n\n\n\n///\n/// Renders media queries based one one or more breakpoint definitions.\n///\n/// @param {?Number|Literal|List<String>|List<Literal>|List<List<String>>} $breakpoint-definitions - a list of breakpoint definitions according to build-breakpoint-query\n///\n/// @see build-breakpoint-query\n/// @example\n///   @include breakpoint(small){\n///     ...\n///   }\n///   @include breakpoint(small down, large up){\n///     ...\n///   }\n///\n@mixin breakpoint($breakpoint-definitions...){\n\t@each $breakpoint-definition in $breakpoint-definitions {\n\t\t$query: build-breakpoint-query($breakpoint-definition);\n\t\t$breakpoint: if(list.length($breakpoint-definition) > 0, list.nth($breakpoint-definition, 1), 0);\n\t\t$direction: if(list.length($breakpoint-definition) > 1, list.nth($breakpoint-definition, 2), 'up');\n\t\t$breakpoint-index: index(map.keys($jig---breakpoint-config), list.nth($breakpoint-definition, 1));\n\t\t$print-breakpoint-index: list.index(map.keys($jig---breakpoint-config), $jig---print-breakpoint);\n\n\t\t// set current breakpoint var to mixin breakpoint value to allow for auto-evaluation inside\n\t\t@if is-named-breakpoint($breakpoint){\n\t\t\t@include set-auto-breakpoint($breakpoint);\n\t\t}\n\n\t\t@if $query == '' {\n\t\t\t@content;\n\t\t} @else {\n\t\t\t@if(\n\t\t\t\t($breakpoint-index != null)\n\t\t\t\tand (\n\t\t\t\t\t($breakpoint-index <= $print-breakpoint-index)\n\t\t\t\t\tor ($direction == 'down')\n\t\t\t\t)\n\t\t\t){\n\t\t\t\t@media print, screen and #{$query} {\n\t\t\t\t\t@content;\n\t\t\t\t}\n\t\t\t} @else {\n\t\t\t\t@media screen and #{$query} {\n\t\t\t\t\t@content;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// restore initial value after mixin has been rendered\n\t\t@include reset-auto-breakpoint();\n\t}\n}\n\n\n\n///\n/// Search for a value, defined for a breakpoint, in a given map of values.\n/// The function escalates in a mobile-first manner. So we take the value for the smallest breakpoint\n/// and step up the breakpoints one by one until we reach the defined breakpoint. So, if we want the\n/// according value for \"large\", but we only have a value for \"medium\", we'll get the \"medium\" value, which,\n/// in mobile-first manner, escalates upwards and is the \"large\" value if nothing else is defined.\n///\n/// @param {*|Map} $value - a map of breakpoint-keyed map of values\n/// @param {Literal|String} $breakpoint - either \"auto\" (to use the current breakpoint) or one of the defined named layout breakpoints\n/// @return {*|null} the breakpoint value or null if nothing was found\n///\n/// @example\n///   breakpoint-value((\n///     'small' : 10px,\n///     'medium' : 20px\n///   ), large);\n///     => 20px\n///\n@function breakpoint-value($value, $breakpoint:'auto'){\n\t@if ($breakpoint != 'auto') and not map.has-key($jig---breakpoint-config, $breakpoint) {\n\t\t@error 'jig:breakpoint-value | given breakpoint \"#{$breakpoint}\" not defined';\n\t}\n\n\t@if meta.type-of($value) == 'map' {\n\t\t$res: null;\n\n\t\t@if $breakpoint == 'auto' {\n\t\t\t$breakpoint: get-auto-breakpoint();\n\t\t}\n\n\t\t@each $breakpoint-name, $breakpoint-definition in $jig---breakpoint-config {\n\t\t\t$breakpoint-value: map.get($value, $breakpoint-name);\n\n\t\t\t@if $breakpoint-value != null {\n\t\t\t\t$res: $breakpoint-value;\n\t\t\t}\n\n\t\t\t@if $breakpoint-name == $breakpoint {\n\t\t\t\t@return $res;\n\t\t\t}\n\t\t}\n\n\t\t@return null;\n\t} @else {\n\t\t@return $value;\n\t}\n}\n\n\n\n///\n/// Renders attribute values for given attributes for defined breakpoints.\n///\n/// Definitions will be rendered together if possible, minimizing the amount of media queries.\n/// However, each call of this mixin will, most likely, render multiple media queries, so keep a close eye\n/// on your media query structure to avoid unnecessarily doubled definitions and keep media queries to a minimum.\n/// If in doubt, it might be a better idea to write the queries manually, perhaps rather using `map-get` or\n/// `breakpoint-value` to automatically pull values from breakpoint value maps.\n///\n/// @param {Map} $attributes - keys are attribute names, while values are either plain values or maps with breakpoint name keys, providing different values per breakpoint\n/// @param {Number} [$factor=null] - if a float factor is provided all values will be multiplied with this factor\n///\n/// @example\n///   @include attributes-for-breakpoints(\n///     (\n///       'font-size' : 12px,\n///       'line-height' : (\n///         'small' : 1,\n///         'large' : 1.25\n///       ),\n///       'margin-top' : (\n///         'small' : 10px,\n///         'medium' : 20px\n///       )\n///     ),\n///     2.0\n///   );\n///\n@mixin attributes-for-breakpoints($attributes, $factor:null){\n\t$attributes-for-breakpoints: ();\n\t@each $attribute-name, $attribute-value in $attributes {\n\t\t@if meta.type-of($attribute-value) != 'map' {\n\t\t\t@if $factor == null {\n\t\t\t\t#{$attribute-name}: $attribute-value;\n\t\t\t} @else {\n\t\t\t\t#{$attribute-name}: ($factor * $attribute-value);\n\t\t\t}\n\t\t} @else {\n\t\t\t@each $breakpoint-name, $breakpoint-definition in $jig---breakpoint-config {\n\t\t\t\t$breakpoint-value: map.get($attribute-value, $breakpoint-name);\n\t\t\t\t@if $breakpoint-value != null {\n\t\t\t\t\t$breakpoint-attributes: map.get($attributes-for-breakpoints, $breakpoint-name);\n\t\t\t\t\t@if $breakpoint-attributes == null {\n\t\t\t\t\t\t$breakpoint-attributes: ();\n\t\t\t\t\t}\n\n\t\t\t\t\t$breakpoint-attributes: map.merge(\n\t\t\t\t\t\t$breakpoint-attributes,\n\t\t\t\t\t\t($attribute-name : $breakpoint-value)\n\t\t\t\t\t);\n\n\t\t\t\t\t$attributes-for-breakpoints: map.merge(\n\t\t\t\t\t\t$attributes-for-breakpoints,\n\t\t\t\t\t\t($breakpoint-name : $breakpoint-attributes)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@each $breakpoint-name, $breakpoint-definition in $jig---breakpoint-config {\n\t\t$breakpoint-attributes: map.get($attributes-for-breakpoints, $breakpoint-name);\n\t\t@if ($breakpoint-attributes != null) and (list.length(map.keys($breakpoint-attributes)) > 0) {\n\t\t\t@include breakpoint($breakpoint-name){\n\t\t\t\t@each $attribute-name, $attribute-value in $breakpoint-attributes {\n\t\t\t\t\t@if $factor == null {\n\t\t\t\t\t\t#{$attribute-name}: $attribute-value;\n\t\t\t\t\t} @else {\n\t\t\t\t\t\t#{$attribute-name}: ($factor * $attribute-value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n///\n/// Renders attribute values for given attribute for defined breakpoints.\n///\n/// This is the single attribute version of `attributes-for-breakpoints`.\n/// Since this version does not optimize the usage of media queries, please make sure to only use this mixin,\n/// if you'll definitely only have one attribute to be defined in multiple breakpoints.\n///\n/// @param {String} $attribute - the name of the attribute you want to set\n/// @param {*} $value - the value to set the attribute to\n/// @param {Number} [$factor=null] - if a float factor is provided the value will be multiplied with this factor\n///\n/// @example\n///   @include attribute-for-breakpoints(\n///     'line-height',\n///     (\n///       'small' : 1,\n///       'large' : 1.25\n///     ),\n///     1.0\n///   );\n///\n@mixin attribute-for-breakpoints($attribute, $value, $factor:null){\n\t$attributes: ();\n\t$attributes: map.merge($attributes, ('#{$attribute}' : $value));\n\t@include attributes-for-breakpoints($attributes, $factor);\n}\n\n\n\n///\n/// Use this, if you need to overwrite attribute values previously defined in (a) breakpoint(s).\n///\n/// A use case might be, for example, to set a font-size to a static value in an element with a responsive,\n/// breakpoint-based font-size definition.\n///\n/// @param {Map} $attributes - keys are attribute names, while values are either plain values or maps with breakpoint name keys, providing different values per breakpoint\n/// @param {Number} [$factor=null] - if a float factor is provided all values will be multiplied with this factor\n///\n/// @example\n///   @include overwrite-breakpoint-for-attributes(\n///     (\n///       'font-size' : 12px,\n///       'line-height' : 1.25\n///       'margin-top' : 20px\n///     ),\n///     2.0\n///   );\n///\n@mixin overwrite-breakpoint-for-attributes($attributes, $factor:null){\n\t@include breakpoint(0){\n\t\t@each $attribute-name, $attribute-value in $attributes {\n\t\t\t@if $factor == null {\n\t\t\t\t#{$attribute-name}: $attribute-value;\n\t\t\t} @else {\n\t\t\t\t#{$attribute-name}: ($factor * $attribute-value);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n///\n/// Use this, if you need to overwrite an attribut value previously defined in (a) breakpoint(s).\n///\n/// A use case might be, for example, to set a font-size to a static value in an element with a responsive,\n/// breakpoint-based font-size definition.\n///\n/// @param {String} $attribute - the name of the attribute you want to set\n/// @param {*} $value - the value to set the attribute to\n/// @param {Number} [$factor=null] - if a float factor is provided the value will be multiplied with this factor\n///\n/// @example\n///   @include overwrite-breakpoint-for-attribute(font-size, 12px, 2.0);\n///\n@mixin overwrite-breakpoint-for-attribute($attribute, $value, $factor:null){\n\t$attributes: ();\n\t$attributes: map.merge($attributes, ('#{$attribute}' : $value));\n\t@include overwrite-breakpoint-for-attributes($attributes, $factor);\n}\n\n\n\n///\n/// Use this, if you need to overwrite something previously defined in (a) breakpoint(s).\n///\n/// A use case might be, for example, to redefine something statically in an override situation, which has\n/// been defined responsively before.\n///\n/// @example\n///   @include overwrite-breakpoint(){\n///     font-size: 12xp;\n///     margin-top: 20px;\n///   }\n///\n@mixin overwrite-breakpoint(){\n\t@include breakpoint('overwrite'){\n\t\t@content;\n\t}\n}\n"]}